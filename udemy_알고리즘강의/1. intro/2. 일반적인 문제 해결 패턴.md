## 2. 일반적인 문제 해결 패턴 파악하기

### 2-1. 빈도수 세기 패턴

- 객체를 사용하여 등장 빈도수를 센다. (Ex. 애너그램 문제)
- 시간복잡도 O(n)을 유지하는 패턴으로 구상한다.
- 분기점을 잘 설정한다.

```js
// 인자로 first, second 문자열 받음
function validAnagram(first, second) {
    if (first.length !== second.length) {
        return false;
    }

    const lookup = {};

    for (let i = 0; i < first.length; i++;) {
        let letter = first[i]
        // 만약 letter가 존재한다면 1을 증가시키고, 존재하지 않으면 1로 초기화한다.
        lookup[letter] ? lookup[letter] += 1 : lookup[letter] = 1;
    }

    for (let i = 0; i < second.length; i++;) {
        let letter = second[i];
        // letter 를 찾을 수 없거나 letter가 0이라면 애너그램이 아니다.
        if (!lookup[letter]) {
            return false;
        } else {
            lookup[letter] -= 1;
        }
    }
    return true;
}
```

### 2-2. 다중 포인터 패턴

- 인덱스나 위치에 해당하는 포인터 값을 만든 후, 조건에 따라 이동시키며 특정 위치를 가리키게 한다.
- 조건에 맞는 한 쌍을 찾기 위해 배열이나 문자열 같은 선형 구조나, 이중 연결 리스트나 단일 연결 리스트를 만드는 것이다.
- 입력값은 정렬되어 있어야 한다. 만약 아니라면, 정렬부터 해야 한다.
- 이중 for문을 사용하면 시간복잡도가 O(n^2)가 되는 반면, 다중 포인터 패턴을 사용하면 O(n)으로 줄일 수 있다.

```js
// 배열 속 두 개의 숫자의 합이 0이 되는 첫 쌍을 찾아내는 sumZero 함수를 만드세요.
// 입력값: 정수들이 오름차순 정렬된 배열
// 반환값: 첫 쌍(2개의 정수)을 원소로 갖는 배열 또는 쌍이 존재하지 않는다면 undefined를 반환.

function sumZero(arr) {
  let left = 0;
  let right = arr.length - 1;
  while (left < right) {
    let sum = arr[left] + arr[right];
    if (sum === 0) {
      return [arr[left], arr[right]];
    } else if (sum > 0) {
      right--;
    } else {
      left++;
    }
  }
}
```

```js
// 배열 속 고유한 값의 갯수를 세는 countUniqueValues 함수를 만드세요.
// 입력값: 정수들이 오름차순 정렬된 배열
// 반환값: 배열 속 고유한 값의 갯수를 나타내는 정수 또는 값이 존재하지 않는다면 undefined 반환.

function countUniqueValues(arr) {
    // arr가 빈 배열일 경우의 단락평가 추가
    if (arr.length === 0) return 0;

    let i = 0;
    for (let j = 1; j < arr.length; j++;) {
        if(arr[i] !== arr[j]) {
            i++;
            arr[i] = arr[j];
        }
    }
    return i + 1;
}
```