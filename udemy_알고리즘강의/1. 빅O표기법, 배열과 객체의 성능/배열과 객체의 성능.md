JavaScript의 배열, 객체, 내장 메서드의 시간복잡도(big O)를 알아보자.

## 목표

1. 객체와 배열이 어떻게 움직이는지 big O의 관점에서 이해할 수 있다.
2. 왜 배열의 맨 앞에 요소를 추가하는 것이 비싼지 설명할 수 있다.
3. 배열과 객체의 내장 메서드의 런타임을 비교할 수 있다.

## 객체

- 정렬되지 않은, 키-값의 쌍으로 이루어진 자료구조.

- 객체를 써야 할 때:

  - 순서가 필요하지 않을 때
  - 빠른 접근, 삽입, 제거가 필요할 때

- 객체의 big O (암기할 필요 없음! 이해만 하면 됨!)

  - 삽입: O(1)
  - 제거: O(1)
  - 검색: O(N)
  - 접근: O(1)

- 객체의 내장 메서드 big O
  - Object.keys: O(N)
  - Object.values: O(N)
  - Object.entries: O(N)
  - hasOwnProperty: O(1)

## 배열

- 정렬된 리스트.

- 배열을 써야 할 때:

  - 순서가 필요할 때
  - 빠른 접근, 삽입, 제거가 필요할 때 (그러나 상황에 따라 달라진다.)

- 배열의 big O

  - 삽입: 어느 위치에 삽입하느냐에 따라 달라짐
  - 제거: 삽입과 같음
  - 검색: O(N)
  - 접근: O(1)

- 배열의 내장 메서드 big O

  - push: O(1) -- push, pop은 배열의 끝에서 이루어지므로 항상 shift, unshift보다 빠르다.
  - pop: O(1)
  - shift: O(N)
  - unshift: O(N)
  - concat: O(N)
  - slice: O(N)
  - splice: O(N)
  - sort: O(N \* log N)
  - forEach/map/filter/reduce/etc.: O(N)

- 배열의 한계점
  - 배열의 시작점에 삽입/제거를 하는 것은 인덱스를 재정렬해야 하므로 생각보다 비쌀 수 있다.
  - 시작점에 삽입/제거를 자주 한다면, 배열보다 더 효과적인 자료구조를 선택하는 것이 좋다.
